#!/usr/bin/env bash
set -e

if [ -t 1 ] && [ -z "$SHY_NO_COLOR" ]; then
  c_reset=$(tput sgr0)
  c_bold=$(tput bold)
  c_blue=$(tput setaf 4)
  c_white=$(tput setaf 7)
fi

### Utilities

warn() {
  echo "shy: $@" 1>&2;
}

die() {
  warn "$@"
  exit 1
}

debug() {
  [ -n "$SHY_DEBUG" ] && warn "$@"
  return 0
}

# Get data for a plugin with the given name
get_plugin_data() {
  local name=$1
  echo $SHY_PLUGIN_DATA | tr '|' '\n' | grep "^${name};"
}

plugin_field() {
  echo $1 | cut -d ';' -f $2
}

plugin_name() { plugin_field "$1" 1; }
plugin_file() { plugin_field "$1" 2; }
plugin_aliases() { plugin_field "$1" 3 | tr ':' '\n'; }
plugin_functions() { plugin_field "$1" 4 | tr ':' '\n'; }
plugin_variables() { plugin_field "$1" 5 | tr ':' '\n'; }

realpath() {
  local native=$(type -p grealpath realpath | head -1)
  if [ -n "$native" ]; then
    $native "$1"
  else
    [[ $1 = /* ]] && echo "$1" || echo "$PWD/${1#./}"
  fi
}

# Returns 0 if an exact match is included in a list, non-zero otherwise.
includes() {
  echo "$1" | grep -q "^$2$"
}

# Takes a semicolon-delimited list and prints it with a nice title. Prints
# nothing if the list is empty.
fancy_list() {
  local items="$1" title="$2"
  [ -z "$items" ] && return
  echo -e "\n${c_bold}${c_blue}== ${c_white}$title${c_blue} ==${c_reset}"
  echo "$items"
}

singularize_type() {
  case "$1" in
    aliases) echo alias ;;
    functions) echo function ;;
    variables) echo variable ;;
  esac
}

# Takes the name of an item (function, alias, or variable) and echos the names
# of any plugins it is included in, if any, followed by the type of item. The
# plugin name and type of item are separated by a colon.
#
# Example
#   find_item my_func
#   => my_plugin:function
find_item() {
  local item_name="$1"
  for plugin_name in $(list_plugins); do
    local plugin=$(get_plugin_data $plugin_name)
    for item_type in aliases functions variables; do
      if includes "$(plugin_${item_type} "$plugin")" $item_name; then
        echo "$plugin_name:$(singularize_type $item_type)"
        return
      fi
    done
  done
  return 1
}

plugin_cache_dir() {
  if [ -n "$SHY_CACHE_DIR" ]; then
    if [ -d "$SHY_CACHE_DIR" ]; then
      echo "$SHY_CACHE_DIR";
      return;
    else
      warn "SHY_CACHE_DIR is not a directory: $SHY_CACHE_DIR";
    fi
  fi

  echo "$HOME/.shy_plugin_cache"
}

initialize_cache() {
  if [ ! -d "$SHY_CACHE_DIR" ]; then
    mkdir "$SHY_CACHE_DIR" || { warn "Could not create cache directory: $SHY_CACHE_DIR"; return 1; }
  fi
}

plugin_name_for_path() {
  basename "${1%.*}"
}

cache_file_path() {
  local plugin_name="$(plugin_name_for_path "$1")"
  echo "$(plugin_cache_dir)/$plugin_name"
}


### Top-level functions

list_plugins() {
  echo $SHY_PLUGIN_DATA | tr '|' '\n' | cut -d ';' -f 1
}

show_plugin() {
  local plugin_data=$(get_plugin_data $1)
  [ -z "$plugin_data" ] && die "Unknown plugin name: $1"
  local name source_file aliases funcs vars
  name=$(plugin_name "$plugin_data")
  source_file=$(plugin_file "$plugin_data")
  aliases=$(plugin_aliases "$plugin_data")
  funcs=$(plugin_functions "$plugin_data")
  vars=$(plugin_variables "$plugin_data")

  echo "${c_bold}Plugin name:${c_reset} $name"
  echo "${c_bold}Source file:${c_reset} $source_file"
  fancy_list "$aliases" 'Aliases'
  fancy_list "$funcs" 'Functions'
  fancy_list "$vars" 'Variables'
  echo ''
}

# Opens the source file of the plugin with the given name in an editor. If the
# names is not a plugin name then functions, aliases, and variables and the
# plugin source file containing the item is opened in an editor.
edit_plugin() {
  local item_name="$1"
  local plugin_data=$(get_plugin_data $item_name)
  if [ -z "$plugin_data" ]; then
    local plugin_name_and_item_type=$(find_item $item_name)
    if [ -n "$plugin_name_and_item_type" ]; then
      plugin_data=$(get_plugin_data ${plugin_name_and_item_type%:*})
    fi
  fi
  [ -z "$plugin_data" ] && die "Unknown plugin, function, alias, or variable: $1"

  local editor=$SHY_EDITOR
  [ -z "$editor" ] && editor=$EDITOR
  [ -z "$editor" ] && editor=vim

  $editor $(plugin_file "$plugin_data")
}

which_plugin() {
  local item_name="$1"
  local plugin_name_and_item_type=$(find_item $item_name)
  if [ -n "$plugin_name_and_item_type" ]; then
    local plugin_name=${plugin_name_and_item_type%:*}
    local item_type=${plugin_name_and_item_type##*:}
    local article=a
    [ "$item_type" = "alias" ] && article=an
    echo "$item_name is $article $item_type in the plugin $plugin_name"
  else
    echo "($item_name not found in any plugin)" >&2
    return 1
  fi
}

write_cache() {
  local plugin_path="$1" plugin_content="$2"
  initialize_cache || return 1
  local plugin_cache_file=$(cache_file_path "$plugin_path")
  echo $plugin_content > $plugin_cache_file
}

read_cache() {
  local plugin_path="$1"
  [ -d "$SHY_CACHE_DIR" ] || return 1
  local plugin_cache_file=$(cache_file_path "$plugin_path")
  [ -f "$plugin_cache_file" ] || return 1
  [ "$plugin_path" -nt "$plugin_cache_file" ] && return 1
  debug "Reading plugin data from cache: $plugin_cache_file"
  cat "$plugin_cache_file"
}

# Prints functionss that need to directly manipulate the interactive shell's environment (and a
# few helpers). This is expected to be eval-ed when the shell loads.
print_initialization() {
  cat <<EOS
shy() {
  case "\$1" in

    ### Porcelain

    # Load a plugin from a file
    load)
      local plugin_file=\$2 plugin_name new_plugin_data
      if [ -z "\$2" ]; then
        shy _err "Usage: shy load PLUGIN_NAME"
      elif [ ! -f "\$plugin_file" ]; then
        shy _err "shy: file does not exist: \$plugin_file"
      else
        plugin_file=\$(shy _realpath \$plugin_file)
        plugin_name="\$(basename \${plugin_file%.*})"

        shy _debug "Loading plugin: \${plugin_file}..."
        if new_plugin_data=\$(shy _read_cache "\$plugin_file"); then
          new_plugin_data="\$plugin_name;\$plugin_file;\$new_plugin_data"
        else
          shy _detect-env-additions source "\$2"
          new_plugin_data="\$plugin_name;\$plugin_file;\$SHY_TMP_DATA"
          shy _write_cache "\$plugin_file" "\$SHY_TMP_DATA"
          unset SHY_TMP_DATA
        fi

        [ -n "\$SHY_PLUGIN_DATA" ] && SHY_PLUGIN_DATA="\$SHY_PLUGIN_DATA|"
        export SHY_PLUGIN_DATA="\$SHY_PLUGIN_DATA\$new_plugin_data"
      fi
      ;;

    list|plugins)
      command shy list
      ;;

    show)
      command shy "\$@"
      ;;

    ### Plumbing

    _debug)
      if [ -n "\$SHY_DEBUG" ] && [ -n "\$2" ]; then
        echo "shy: \$2" >&2
      fi
      ;;

    _err)
      shift
      [ -n "\$@" ] && { echo "\$@" >&2; }
      return 1
      ;;

    _pathify)
      echo \$2 | tr "\$IFS" ':' | sed 's/:\$//'
      ;;

    _aliases)
      local raw_aliases
      if [ -n "\$ZSH_VERSION" ]; then
        raw_aliases="\$(alias)"
      else
        raw_aliases="\$(alias | cut -d ' ' -f 2-)"
       fi
      shy _pathify "\$(echo "\$raw_aliases" | cut -d '=' -f 1 | sort)"
      ;;

    _functions)
      local funcs
      if [ -n "\$ZSH_VERSION" ]; then
       funcs="\$(print -l \${(ok)functions})"
      else
        funcs="\$(typeset -F | cut -d ' ' -f 3)"
      fi
      shy _pathify "\$funcs"
      ;;

    _variables)
      shy _pathify "\$(env | cut -d '=' -f 1 | sort)"
      ;;

    # Capture names of aliases, functions, and variables in the current environment
    _capture-env)
      echo "\$(shy _aliases);\$(shy _functions);\$(shy _variables)"
      ;;

    # Run the given command command and detect additions to the environment that occurred
    _detect-env-additions)
      local before after additions additions_for_type
      before=\$(shy _capture-env)
      shift
      "\$@"
      after=\$(shy _capture-env)
      # TODO clean this up
      for n in 1 2 3; do
        additions_for_type=\$(comm -13 <(echo \$before | cut -d ';' -f "\$n" | tr ':' '\n') <(echo \$after | cut -d ';' -f "\$n" | tr ':' '\n'))
        additions="\${additions}\$(shy _pathify "\$additions_for_type")"
        [ "\$n" -lt "3" ] && additions="\$additions;"
      done
      # Ugh, figure out a way to not use this?
      SHY_TMP_DATA="\$additions"
      ;;

    *)
      command shy "\$@"
      ;;

  esac
}
EOS
}

case "$1" in
  init) print_initialization ;;

  list) list_plugins ;;
  show|edit|which) ${1}_plugin "$2" ;;

  _realpath|_read_cache|_write_cache)
    cmd=${1:1}
    shift
    $cmd "$@" ;;

esac
