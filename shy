#!/usr/bin/env bash

if [ -t 1 ] && [ -z "$SHY_NO_COLOR" ]; then
  c_reset=$(tput sgr0)
  c_bold=$(tput bold)
  c_blue=$(tput setaf 4)
  c_white=$(tput setaf 7)
fi

### Utilities

die() {
  echo $1 >&2;
  exit 1
}

debug() {
  [ -n "$SHY_DEBUG" ] && echo "shy: $1" >&2;
}

# Get data for a plugin with the given name
get_plugin_data() {
  local name=$1
  echo $SHY_PLUGIN_DATA | tr '|' '\n' | grep "^${name};"
}

plugin_field() {
  echo $1 | cut -d ';' -f $2
}

plugin_name() {
  plugin_field "$1" 1
}

plugin_file() {
  plugin_field "$1" 2
}

realpath() {
  local native=$(type -p grealpath realpath | head -1)
  if [ -n "$native" ]; then
    $native "$1"
  else
    [[ $1 = /* ]] && echo "$1" || echo "$PWD/${1#./}"
  fi
}

# Takes a semicolon-delimited list and prints it with a nice title. Prints
# nothing if the list is empty.
fancy_list() {
  local items="$1" title="$2"
  [ -z "$items" ] && return
  echo -e "\n${c_bold}${c_blue}== ${c_white}$title${c_blue} ==${c_reset}"
  echo $items | tr ':' '\n'
}

### Top-level functions

list_plugins() {
  echo $SHY_PLUGIN_DATA | tr '|' '\n' | cut -d ';' -f 1
}

show_plugin() {
  local plugin_data=$(get_plugin_data $1)
  [ -z "$plugin_data" ] && die "Unknown plugin name: $1"
  local name source_file aliases funcs vars
  name=$(plugin_name "$plugin_data")
  source_file=$(plugin_file "$plugin_data")
  aliases=$(plugin_field "$plugin_data" 3)
  funcs=$(plugin_field "$plugin_data" 4)
  vars=$(plugin_field "$plugin_data" 5)

  echo "${c_bold}Plugin name:${c_reset} $name"
  echo "${c_bold}Source file:${c_reset} $source_file"
  fancy_list "$aliases" 'Aliases'
  fancy_list "$funcs" 'Functions'
  fancy_list "$vars" 'Variables'
  echo ''
}

edit_plugin() {
  local plugin_data=$(get_plugin_data $1)
  [ -z "$plugin_data" ] && die "Unknown plugin: $1"

  local editor=$SHY_EDITOR
  [ -z "$editor" ] && editor=$EDITOR
  [ -z "$editor" ] && editor=vim

  $editor $(plugin_file "$plugin_data")
}

# Prints functionss that need to directly manipulate the interactive shell's environment (and a
# few helpers). This is expected to be eval-ed when the shell loads.
print_initialization() {
  cat <<EOS
shy() {
  case "\$1" in

    ### Porcelain

    # Load a plugin from a file
    load)
      local plugin_file=\$2 plugin_name new_plugin_data
      if [ -z "\$2" ]; then
        shy _err "Usage: shy load PLUGIN_NAME"
      elif [ ! -f "\$plugin_file" ]; then
        shy _err "shy: file does not exist: \$plugin_file"
      else
        plugin_file=\$(shy _realpath \$plugin_file)
        plugin_name="\$(basename \${plugin_file%.*})"
        shy _debug "Loading plugin: \${plugin_file}..."

        shy _detect-env-additions source "\$2"
        # TODO capture absolute file path
        new_plugin_data="\$plugin_name;\$plugin_file;\$SHY_TMP_DATA"
        unset SHY_TMP_DATA

        [ -n "\$SHY_PLUGIN_DATA" ] && SHY_PLUGIN_DATA="\$SHY_PLUGIN_DATA|"
        export SHY_PLUGIN_DATA="\$SHY_PLUGIN_DATA\$new_plugin_data"
      fi
      ;;

    list|plugins)
      command shy list
      ;;

    show)
      shift
      command shy show "\$@"
      ;;

    ### Plumbing

    _debug)
      if [ -n "\$SHY_DEBUG" ] && [ -n "\$2" ]; then
        echo "shy: \$2" >&2
      fi
      ;;

    _err)
      [ -n "\$2" ] && { echo "\$2" >&2; }
      return 1
      ;;

    _pathify)
      echo \$2 | tr "\$IFS" ':' | sed 's/:\$//'
      ;;

    _aliases)
      local raw_aliases
      if [ -n "\$ZSH_VERSION" ]; then
        raw_aliases="\$(alias)"
      else
        raw_aliases="\$(alias | cut -d ' ' -f 2-)"
       fi
      shy _pathify "\$(echo "\$raw_aliases" | cut -d '=' -f 1 | sort)"
      ;;

    _functions)
      local funcs
      if [ -n "\$ZSH_VERSION" ]; then
       funcs="\$(print -l \${(ok)functions})"
      else
        funcs="\$(typeset -F | cut -d ' ' -f 3)"
      fi
      shy _pathify "\$funcs"
      ;;

    _variables)
      shy _pathify "\$(env | cut -d '=' -f 1 | sort)"
      ;;

    # Capture names of aliases, functions, and variables in the current environment
    _capture-env)
      echo "\$(shy _aliases);\$(shy _functions);\$(shy _variables)"
      ;;

    # Run the given command command and detect additions to the environment that occurred
    _detect-env-additions)
      local before after additions additions_for_type
      before=\$(shy _capture-env)
      shift
      "\$@"
      after=\$(shy _capture-env)
      # TODO clean this up
      for n in 1 2 3; do
        additions_for_type=\$(comm -13 <(echo \$before | cut -d ';' -f "\$n" | tr ':' '\n') <(echo \$after | cut -d ';' -f "\$n" | tr ':' '\n'))
        additions="\${additions}\$(shy _pathify "\$additions_for_type")"
        [ "\$n" -lt "3" ] && additions="\$additions;"
      done
      # Ugh, figure out a way to not use this?
      SHY_TMP_DATA="\$additions"
      ;;

    *)
      command shy "\$@"
      ;;

  esac
}
EOS
}

case "$1" in
  init) print_initialization ;;

  list) list_plugins ;;
  show) show_plugin "$2" ;;
  edit) edit_plugin "$2" ;;

  _realpath) realpath "$2" ;;

esac
